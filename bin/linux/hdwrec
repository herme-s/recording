#!/opt/kronometrix/perl/bin/perl
#
#  Copyright (c) 2015 Stefan Parvu (www.kronometrix.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use Sys::Statistics::Linux;
use Linux::Distribution qw(distribution_name distribution_version);
use POSIX qw(pause);
use Sys::Hostname;

# Debug Only
#use Data::Dumper;

### Command line arguments
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

###  Variables
my $sb   = "/sys/block";
$main::opt_h = 0;  # help option
$main::opt_V = 0;  # revision option
my $loop = 0;      # current loop number
my $tp   = 0;      # time precision
my $lsb  = "/usr/bin/lsb_release";
local $| = 1;



### MAIN BODY

# Set a timer for S::S::L object
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .1, .1 );
my $lxs = Sys::Statistics::Linux->new(
    sysinfo  => 1,
    procstats  => 1
);
my $dl = Linux::Distribution->new;
### 0.1sec sleep using a timer
pause;

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

if ( $interval =~ /\./ ) {
    $tp = 3;
}

while (1) {

    # get stats
    my $stat = $lxs->get;
    my $si  = $stat->sysinfo;
    my $ps  = $stat->procstats;

    # hostname
    my $host = hostname;
    $host =~ s/\..*$// if $host =~ /\./;

    # hypervisor type
    my $hypervisor = "NA";

    if (-e "/sys/hypervisor/type") {
        open my $hv, "<", "/sys/hypervisor/type"
            or die "error: cannot find hypervisor type file: $!\n";
        while (<$hv>) {
                chomp;
                $hypervisor = $_;
            }
            close $hv;
        
    }

    # ncores
    my $ncores = $si->{tcpucount};

    # hyper-threading
    my $ht = 'NA';
 
    # disks might become available, check disks every sample
    my $num_disk = 0;

    # get disks
    my $rdisks = get_disks();
    $num_disk =  scalar(@$rdisks);

    # fetch dist_id, os, relos 
    my ($os, $relos) = "NA";

    # get os, relos
    if(my $distro = $dl->distribution_name()) {
        $os = lc $distro;

        if (defined($dl->distribution_version()) && 
           ($dl->distribution_version()) ne "" ) {
            $relos = $dl->distribution_version();
        } else {
            $relos = "NA";
            if ($distro eq "redhat") {
                my $distid;
                ($os, $relos, $distid) = get_lsb("$lsb");
                if (defined $os) {
                    $os = "cloudlinux" if ( $os eq "CloudLinuxServer" );
                } else {
                    if (-e "/etc/redhat-release") {
                        open my $rhelrel, "<", "/etc/redhat-release"
                          or die "error: cannot find redhat-release: $!\n";
                        while (<$rhelrel>) {
                            chomp;
                            if ($_ =~ /^CloudLinux/o) {
                                $os="cloudlinux";
                                $relos = $1 if $_ =~ /(\d+\.\d+(?:\.\d+)?)/;
                            } else {
                                $os = "NA";
                                $relos = "NA";
                            }
                        }
                        close $rhelrel;
                    } else { $os = "NA"; $relos = "NA"; }
                }
            }
        }
    }

    # fetch NICS, reset here if NIC is removed/added
    my $num_nic = 0;
    foreach my $i (split /, /, $si->{interfaces} ) {
        $num_nic++ if $i =~ /eth|wlan/;
    }

    my $memtotal = $si->{memtotal};
    my $swaptotal = $si->{swaptotal};
    $memtotal =~ s/\s+[kK]B$//;
    $swaptotal =~ s/\s+[kK]B$//;

    # print metrics
    printf "%.${tp}f:%s:%s:%s:%s:%s:%s:%d:%d:%d:%s:%s:%s:%d:%d:%s\n",
      time, $host, $si->{arch}, $hypervisor, $os, $relos,
      $si->{release},
      $si->{pcpucount}, $ncores, $si->{tcpucount}, $ht,
      $memtotal, $swaptotal, 
      $num_disk, $num_nic, $si->{uptime};

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;

}



### SUBROUTINES
sub get_lsb {

    my ($lsbfh) = @_;
    my ($o,$r,$d);

    open my $LSBINFO, "-|", "$lsbfh -a 2>/dev/null"
        or die "error: cannot execute lsb_release - $!";

    while (<$LSBINFO>) {
        chomp;
        $d = $1 if $_ =~ /^Distributor ID\:\s+(.*)/; $r = $1 if $_ =~ /^Release\:\s+(.*)/;
    }
    $o = $d;

    close $LSBINFO;

    return ( $o, $r, $d );
}


sub get_disks {

    my @d;

    # get disks
    opendir(my $dh, $sb)
        or die "Error: Cannot find block directory: $!\n";

    while(readdir $dh) {
        # discard parent dir
        next if ($_ =~ m/^\./);

        # exceptions
        next if ($_ =~ m/^loop|^ram|^zram/);
        next if ($_ =~ m/^fd0|^hdc/);
        next if ($_ =~ m/^md(?:[0-9])/);
        next if ($_ =~ m/^dm-(?:[0-9])/);
        next if ($_ =~ m/^sr(?:[0-9])$/);

        # print disks
        # print "Disk: $_\n";
        push @d, "$_"; 
    }
    closedir $dh;
    
    # return array ref
    return \@d;
}  


# usage - print usage and exit.
#
sub usage {
    print STDERR <<END;
USAGE: hdwrec [-hV] | [interval [count]]
 e.g. hdwrec 5       print continuously every 5 seconds
      hdwrec 1 5     print 5 times, every 1 second

 FIELDS:
  #01 timestamp  : seconds since Epoch, time
  #02 hostname   : hostname
  #03 hdw        : machine hardware name
  #04 hypervisor : name of the hypervisor, string
  #05 os         : name of the operating system, string
  #06 relos      : release number of operating system, string
  #07 kernel     : kernel version and release number
  #08 pcpu       : number of physical installed CPUs, number
  #09 cores      : number of physical CPU cores , number
  #10 vcpu       : number of virtual CPUs, number
  #11 ht         : hyper-threading: 0(OFF)/1(ON)/NA, string
  #12 memtotal   : total physical memory installed, number
  #13 swaptotal  : total physical swap installed, number
  #14 disks      : total number of disks, number
  #15 nics       : total number of NICs, number
  #16 uptime     : how long the system has been running, number 

END
    exit 0;
}


# revision - print revision and exit
#
sub revision {
    print STDERR <<END;
hdwrec: 1.0.16, 2015-08-30 1403
END
    exit 0;
}
