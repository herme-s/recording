#!/opt/kronometrix/perl/bin/perl
#
#  Copyright (c) 2015 Stefan Parvu (www.kronometrix.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use JSON;
use File::Temp qw(tempfile);
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use POSIX qw(pause);
use Tie::IxHash;
use HTTP::Response;
use WWW::Curl::Easy;

###  Process command line args
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hvV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# verbose flag
my $verbose_flag = defined $main::opt_v ? $main::opt_v : 0;

# process [interval [count]],
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

###  Variables
my $loop = 0;              # current loop number
$main::opt_h = 0;          # help option
$main::opt_V = 0;          # revision option
my $cfile = 'webrec.json'; # configuration file
my $cdata;                 # configuration data
my $tcpka = 0;             # transport TCP keepalive settings
my $tp = 0;                # time precision

local $| = 1;


### MAIN BODY #

# Set a timer for WWW::Curl::Easy object
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .1, .1 );
my $http = WWW::Curl::Easy->new;

### 0.1sec sleep using a timer
pause;

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

# check interval input
if ( $interval =~ /\./ ) {
    $tp = 3;
}

# read configuration
$cdata = open_config($cfile);

# workloads
tie my %work, "Tie::IxHash";
%work = get_workload($cdata);

# get it as verbose
print "Total workload requests: " . keys(%work) . ".\n";

if (&WWW::Curl::Easy::version() !~ /ssl|nss/i) {
    die "Error: No SSL support";
}

$http->setopt(CURLOPT_NOPROGRESS, 1);
$http->setopt(CURLOPT_FOLLOWLOCATION, 1);
$http->setopt(CURLOPT_NOSIGNAL, 1);
#$http->setopt(CURLOPT_TIMEOUT, 60);

my $head = tempfile();
$http->setopt(CURLOPT_WRITEHEADER, $head);

my $body = tempfile();
$http->setopt(CURLOPT_FILE, $body);

my @myheaders;
$myheaders[0] = "User-Agent: Kronometrix 1.0/webrec";

$http->setopt(CURLOPT_HTTPHEADER, \@myheaders);
$http->setopt(CURLOPT_COOKIEJAR, "cookies.txt"); 

$http->setopt(CURLOPT_FORBID_REUSE, 1);
$http->setopt(CURLOPT_FRESH_CONNECT, 1);
$http->setopt(CURLOPT_CAINFO,"ca-bundle.crt");

# main loop
while (1) {

    for my $key (keys %work) {
        my $value = $work{$key};
        my ( $workload, $desc, $name, $id ) = split ( /:/, $key );
        my ( $scheme, $hostname, $port, $url ) = split( /:/, $value );
        #print "$key => $value\n";
        process_request ($http, $workload, $name, $id, $value);
        # sleep .5;
    }

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;
}



### Subroutines

## configuration file

# open JSON configuration file
sub open_config {

    my ($conf) = @_;

    my $json_data;

    {
        local $/;

        # we will parse now the file
        if ( defined $ENV{'KRMX_PREFIX'} ) {
            if ( -e "$ENV{'KRMX_PREFIX'}/etc/$conf" ) {
                open my $fh, "<", "$ENV{'KRMX_PREFIX'}/etc/$conf";
                $json_data = <$fh>;
                close $fh;
            }
            else {
                print "error: open_conf - $! $ENV{'KRMX_PREFIX'}/etc/$conf \n";
                usage();
            }
        }
        else {
            if ( -e "/opt/kronometrix/etc/$conf" ) {
                open my $fh, "<", "/opt/kronometrix/etc/$conf";
                $json_data = <$fh>;
                close $fh;
            }
            else {
                print "error: open_conf - $! /opt/kronometrix/etc/$conf \n";
                usage();
            }
        }
    }

    my $perl_data = JSON->new->utf8->decode($json_data);

    return $perl_data;
}

# write config file
sub write_config {

    my ( $conf, $perl_data ) = @_;

    # JSON Object
    my $json_data = JSON->new->utf8->pretty->encode($perl_data);

    # we will parse now the file
    if ( defined $ENV{'KRMX_PREFIX'} ) {
        if ( -e "$ENV{'KRMX_PREFIX'}/etc/$conf" ) {
            open my $fh, ">", "$ENV{'KRMX_PREFIX'}/etc/$conf.tmp";

            # print $fh encode_json($data);
            print $fh $json_data;
            close $fh;
            move(
                "$ENV{'KRMX_PREFIX'}/etc/$conf.tmp",
                "$ENV{'KRMX_PREFIX'}/etc/$conf"
            ) or die "Error: cannot update $conf: $!";

        }
        else {
            print "error: write_config - $! $ENV{'KRMX_PREFIX'}/etc/$conf \n";
            usage();
        }
    }
    else {
        if ( -e "/opt/kronometrix/etc/$conf" ) {
            open my $fh, ">", "/opt/kronometrix/etc/$conf.tmp";
            print $fh $json_data;
            close $fh;
            move( "/opt/kronometrix/etc/$conf.tmp", "/opt/kronometrix/etc/$conf" )
              or die "Error: cannot update $conf: $!";
        }
        else {
            print "error: write_config - $! /opt/kronometrix/etc/$conf \n";
            usage();
        }
    }
}

# reload configuration
sub reload_config {

    writelog("info: main - signal HUP received, reload armed...");

    $cdata = open_config($cfile);

    ## hostid
    get_hostid($cdata);

    ## appliance destination
    %work = get_workload($cdata);

    return;
}


# get workloads defintion
sub get_workload {

    my ($data) = @_;
    tie my %appl, "Tie::IxHash";
    #my %appl;

    my @temp = @{ $data->{'workloads'} };

    foreach my $f (@temp) {
        my ($sid, $tid, $dsid);

        # my $proto = $f->{'protocol'};
        # my $port  = $f->{'port'};
        my $ka      = $f->{'keepalive'};
        my $name    = $f->{'name'};
        my $desc    = $f->{'description'};

        my @reqs = @{ $f->{'requests'} };

        foreach my $req (@reqs) {
            my $id  = $req -> {'id'};
            my $met = $req -> {'method'};
            my $scm = $req -> {'scheme'};
            my $hst = $req -> {'host'};
            my $prt = $req -> {'port'};
            my $url = $req -> {'path'};

            # print "$name:$desc:$id:$met => $scm://$hst:$prt$url\n";
            my $keyapp = $name . ":" . $desc . ":" . $id . ":" . $met;
            $appl{$keyapp} = "$scm://$hst:$prt$url";
        }
    }

    return %appl;
}


sub process_request {

    my ($http, $w, $n, $id, $url) = @_;

    if ($id eq "POST") {
#        $http->setopt(CURLOPT_POST,       1 );
#        $http->setopt(CURLOPT_POSTFIELDS, $post );
#        $http->setopt(CURLOPT_SSL_VERIFYPEER,0); # do verify
#        $http->setopt(CURLOPT_SSL_VERIFYHOST,0); # check name
#        $http->setopt(CURLOPT_URL, $url);
#        my $retcode = $http->perform();
#
#        # Get the results
#        $responseCode =  $http->getinfo(CURLINFO_HTTP_CODE);
##        $loadTime = $http->getinfo(CURLINFO_TOTAL_TIME);
#        $connectTime = $http->getinfo(CURLINFO_CONNECT_TIME);
#        $dnsTime = $http->getinfo(CURLINFO_NAMELOOKUP_TIME);
#        $protocolTime = $http->getinfo(CURLINFO_PRETRANSFER_TIME);
#        $pageSize = $http->getinfo(CURLINFO_SIZE_DOWNLOAD);
#        $pktime = abs($http->getinfo(CURLINFO_STARTTRANSFER_TIME) - $dnsTime);
##
#        if ($retcode == 0) {
#            print_results ( $url,          $responseCode, 
#                            $loadTime,     $connectTime, $dnsTime,
#                            $protocolTime, $pageSize,    $packetTime );
    } elsif ($id eq "GET") {

        my $treq = time;
        $http->setopt(CURLOPT_URL, $url);
        my $retcode = $http->perform();

        ## Get the results
        my $response =  $http->getinfo(CURLINFO_HTTP_CODE);
        my $load     = $http->getinfo(CURLINFO_TOTAL_TIME);
        my $connect  = $http->getinfo(CURLINFO_CONNECT_TIME);
        my $dns      = $http->getinfo(CURLINFO_NAMELOOKUP_TIME);
        my $proto    = $http->getinfo(CURLINFO_PRETRANSFER_TIME);
        my $pagesz   = $http->getinfo(CURLINFO_SIZE_DOWNLOAD);
        my $firstpkt = abs($http->getinfo(CURLINFO_STARTTRANSFER_TIME) - $dns);

        if ($retcode == 0) { 
            putraw ($treq, $w, $n, $load, $connect, $dns, $proto, $pagesz, $firstpkt, $response);
 
        } else { print "$w:$n:$url error processing request \r"; }

    } else {
            print "Error: cannot process request: $url \n";
    }
}


#
sub putraw {

    my ( $timereq, $workload, $reqname,  $ttime, $ctime, $dtime, $ptime, $psize, $fpkt, $resp ) = @_;

    printf "%f:%s:%s:%.2f:%.2f:%.2f:%.2f:%.2f:%d:%d\n",
                $timereq, $workload, $reqname,
                $ttime  , $ctime   , $dtime  , $ptime,
                $fpkt   , $psize   , $resp;
}


## auxiliares

# write log message
sub writelog {

    my ($logbuf) = @_;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

    my $dt = sprintf "%4d-%02d-%02d %02d:%02d:%02d",
      $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

    print "\n$dt $logbuf";

    return;
}


# usage - print usage and exit.
sub usage {
    print STDERR <<END;
USAGE: webrec [-t secs] [-hvV] | [interval]
OPTIONS:
  -h        : help information
  -h        : verbose information
  -V        : release version
  interval  : maximum number of seconds between samples, default 60, will 
              never spend more than that without checking data

 e.g. webrec    check and send krd raw data, every 60 secs
      webrec 60 check and send krd raw data, every 10 secs
END
    exit 0;
}

# revision - print revision and exit
sub revision {
    print STDERR <<END;
webrec: 1.0.17, 2015-09-20 1939
END
    exit 0;
}
