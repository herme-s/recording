#
# Copyright (c) 2015 Stefan Parvu (www.kronometrix.org).
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time gettimeofday);
use POSIX qw(pause);
use Win32::OLE ('in');
use Sys::Hostname;
use Time::Local;
use Win32;
use JSON;


# Debug Only
use Data::Dumper;
### Command line arguments
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hvV') or usage();
usage() if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}


# verbose flag
my $verbose_flag = defined $main::opt_v ? $main::opt_v : 0;


### Variables
my $update;                            # used for deltas
my %cpudataOld;                        # cpu_stats data
my $loop        = 0;                   # current loop number
$main::opt_h    = 0;                   # help option
$main::opt_V    = 0;                   # revision option
my $tp          = 0;                   # time precision
my $cf          = 'kronometrix.json';  # default json config
local $|        = 1;                   # autoflush


### MAIN BODY

# how often do we trigger (seconds)?
my $first_interval = $interval;


# check interval input
if ( $interval =~ /\./ ) {
   $tp = 3;
}


# read configuration
my $cdata = open_config($cf);
my ( $blog, $clog, $dlog ) = getlog($cdata);
my $hdwlog = $blog . "/hdwrec.log";


# open raw data
# my $hkrd = get_krd($clog);



# get stats
my $wmi = Win32::OLE->GetObject("winmgmts://./root/cimv2")
    or die "Cannot initialize WMI interface\n";


while(1) {

    # hostname# hostname
    my $host = lc(hostname);
    $host =~ s/\..*$// if $host =~ /\./;


    # measure payload
    my $start = gettimeofday();
    my $wproc = $wmi->InstancesOf("Win32_Processor");
    my $hdw;
    foreach my $obj (in $wproc) {
        $hdw = $obj->{AddressWidth};
    }


    # os, relos, kernel build
    my $os = Win32::GetOSName();
    my ($s, $maj, $min, $build, $id) = Win32::GetOSVersion();
    my $relos = $maj . "." . $min;
    my $kernel = $build;

    # pcpu, vcpu
    my $wcs = $wmi->InstancesOf("Win32_ComputerSystem");
    my ($pcpu, $vcpu);
    foreach my $obj (in $wcs) {
        $pcpu = $obj->{NumberOfProcessors};
        $vcpu = $obj->{NumberOfLogicalProcessors};
    }


    # memtotal, swaptotal
    my $wos = $wmi->InstancesOf("Win32_OperatingSystem");
    my ($memtotal, $swaptotal, $freemem, $lastboot, $currtime);
    foreach my $obj (in $wos) {
        $memtotal  = $obj->{TotalVisibleMemorySize};
        $swaptotal = $obj->{SizeStoredInPagingFiles};
        $freemem   = $obj->{FreePhysicalMemory};
	$lastboot  = $obj->{LastBootUptime};
	$currtime  = $obj->{LocalDateTime};
    }

    my $uptime = get_uptime ($lastboot, $currtime);

    # get no of disks
    # Win32_DiskDrive Class
    my $wd = $wmi->InstancesOf("Win32_DiskDrive");
    my $ndisk = 0;
    foreach my $disk (in $wd) {
        $ndisk++;
    }


    #my $wd2 = $wmi->ExecQuery("SELECT Name FROM Win32_PerfFormattedData_PerfDisk_PhysicalDisk where name != '_Total'", "WQL", 0x10 | 0x20 );
    #foreach my $obj (in $wd2) {
    #    print "$obj->{Name}\n";
    #}

    # get no of NICs
    # Win32_NetworkAdapterConfiguration
    my $wn = $wmi->InstancesOf("Win32_NetworkAdapterConfiguration");
    my $nnic = 0;
    foreach my $nic (in $wn) {
        if ( defined($nic->{MACAddress}) and 
	     defined($nic->{IPAddress} ) ) {
            $nnic++;
	}
    }
    
    my $end = gettimeofday();
    my $elapsed = ($end - $start) * 1000;


    # print "elapsed time: $elapsed ms\n";

    printf "%.${tp}f:%s:%s:%s:%s:%s:%d:%d:%s:%s:%d:%d:%s\n", 
      time , $host, $hdw, lc($os), $relos, $kernel, $pcpu, $vcpu,
      $memtotal, $swaptotal, $ndisk, $nnic, $uptime;

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    Win32::Sleep(($interval * 1000 ) - $elapsed);

}


### SUBROUTINES

# chklog - check log directory
#
sub chklog {

    my ($dir) = @_;

    if (defined $dir) {
        if (! -d $dir) {
            print "error: chklog - cannot find $dir log directory";
	    usage();
        }
    } else {
        print "error: chklog - cannot find $dir log directory";
	usage();
    }

    return;
}


# open_config - open JSON configuration file
#
sub open_config {

    my ($conf) = @_;
    my $json_data;

    {
        local $/;

        # we will parse now the file
	if ( defined $ENV{'KRMX_PREFIX'} ) {
	    if ( -e "$ENV{'KRMX_PREFIX'}/etc/$conf" ) {
	        open my $fh, "<", "$ENV{'KRMX_PREFIX'}/etc/$conf";
	        $json_data = <$fh>;
	        close $fh;
	    } else {
                print "error: open_config - $! $ENV{'KRMX_PREFIX'}/etc/$conf \n";
	        usage();
	    }
	} else {
	    if ( -e "C:\\Kronometrix\\etc\\$conf" ) {
		open my $fh, "<", "C:\\Kronometrix\\etc\\$conf";
		$json_data = <$fh>;
		close $fh;
	    } else { 
	        print "error: open_config - $! $conf \n"; 
		usage(); 
	    }
	} 
    }
    
    my $perl_data = JSON->new->utf8->decode($json_data); 
    
    return $perl_data;
}


# getlog - get log directory information
#
sub getlog {
    my ($data) = @_;

    my $bpath = $data->{'log'}->{'base_path'};
    chklog($bpath);

    my $cpath = $data->{'log'}->{'current_path'};
    chklog($cpath);

    my $dpath = $data->{'log'}->{'daily_path'};
    chklog($dpath);

    return ( $bpath, $cpath, $dpath );
}


# get_uptime - return system uptime
#
sub get_uptime {

    my ($lb, $ct) = @_;

    # extract lastboot time
    my $lyr   = substr ($lb, 0, 4);
    my $lmon  = substr ($lb, 4, 2);
    my $lday  = substr ($lb, 6, 2);
    my $lhrs  = substr ($lb, 8, 2);
    my $lmin  = substr ($lb, 10, 2);
    my $lsec  = substr ($lb, 12, 2);

    my $cyr   = substr ($ct, 0, 4);
    my $cmon  = substr ($ct, 4, 2);
    my $cday  = substr ($ct, 6, 2);
    my $chrs  = substr ($ct, 8, 2);
    my $cmin  = substr ($ct, 10, 2);
    my $csec  = substr ($ct, 12, 2);

    # print "Last timeboot: $lyr $lmon $lday $lhrs $lmin $lsec\n";
    # print "Current DateTime: $cyr $cmon $cday $chrs $cmin $csec\n";

    my $bootTime = timelocal($lsec, $lmin, $lhrs, $lday, $lmon, $lyr);
    my $currentTime = timelocal($csec, $cmin, $chrs, $cday, $cmon, $cyr);

    my $delta = $currentTime - $bootTime;
    my ($secs, $mins, $hrs, $days);
    $secs    =  $delta % 60;
    $delta   = ($delta - $secs) / 60;
    $mins    =  $delta % 60;
    $delta   = ($delta - $mins) / 60;
    $hrs     =  $delta % 24;
    $delta   = ($delta - $hrs)   / 24;
    $days    =  $delta;

    my $u = "$days" . "d " . "$hrs" . "h " . "$mins" . "m " . "$secs" . "s";

    # return uptime
    return $u;
}


# writelog - write log message
#
sub writelog {

    my ($logbuf) = @_;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
    localtime(time);

    my $dt = sprintf "%4d-%02d-%02d %02d:%02d:%02d",
                $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

    print "\n$dt $logbuf";

    return;
}


# usage - print usage and exit
#
sub usage {
    print STDERR <<END;
USAGE: hdwrec [-hV] | [interval [count]]
 e.g. hdwrec 5       print continuously every 5 seconds
      hdwrec 1 5     print 5 times, every 1 second

 FIELDS:
  #01 timestamp  : seconds since Epoch, time
  #02 hostname   : hostname
  #03 hdw        : machine hardware name
  #04 hypervisor : name of the hypervisor, string
  #05 os         : name of the operating system, string
  #06 relos      : release number of operating system, string
  #07 kernel     : kernel version and release number
  #08 pcpu       : number of physical installed CPUs, number
  #09 vcpu       : number of virtual CPUs, number
  #10 memtotal   : total physical memory installed, number
  #11 swaptotal  : total physical swap installed, number
  #12 disks      : total number of disks, number
  #13 nics       : total number of NICs, number
  #14 uptime     : total number of NICs, number
END
    exit 0;
}


# revision - print revision and exit
#
sub revision {
    print STDERR <<END;
hdwrec: 1.0.15, 2015-04-23 2347
END
    exit 0;
}
