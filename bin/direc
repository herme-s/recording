#!/opt/kronometrix/perl/bin/perl
#
#  Copyright (c) 2016 Stefan Parvu (www.kronometrix.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use JSON;
use Getopt::Std;
use Net::NTP;
use Tie::IxHash;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use POSIX qw(pause);

###  Process command line args
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hvV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# verbose flag
my $verbose_flag = defined $main::opt_v ? $main::opt_v : 0;

# process [interval [count]],
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

###  Variables
my $loop = 0;              # current loop number
$main::opt_h = 0;          # help option
$main::opt_V = 0;          # revision option
my $cfile = 'direc.json';  # configuration file
my $cdata;                 # configuration data
my $tp = 0;                # time precision

local $| = 1;


### MAIN BODY #

# Set a timer for WWW::Curl::Easy object
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .1, .1 );
#my $http = WWW::Curl::Easy->new;

### 0.1sec sleep using a timer
pause;

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

# check interval input
if ( $interval =~ /\./ ) {
    $tp = 3;
}

# read configuration
$cdata = open_config($cfile);

# servers
tie my %work, "Tie::IxHash";
%work = get_server($cdata);

# get it as verbose
# print "Total workload requests: " . keys(%work) . ".\n";

my $server = 'north-america.pool.ntp.org';

# main loop
while (1) {

    for my $key (keys %work) {
        
        my $value = $work{$key};

        my ($port, $desc) = split( /:/, $value );

        my $t0 = time;
        my %h = get_ntp_response($key);

        my $T1 = $t0;                      #Originate Timestamp;
        my $T2 = $h{'Receive Timestamp'};  #
        my $T3 = $h{'Transmit Timestamp'}; #
        my $T4 = time;                     #
  
        #d = (T4 - T1) - (T3 - T2)     
        my $d = ($T4 - $T1) - ($T3 - $T2);

        #t = ((T2 - T1) + (T3 - T4)) / 2.
        my $t = (($T2 - $T1) + ($T3 - $T4)) / 2;

        my $duration = $T4 - $t0;
        my $delta = $T2 - $T1 - $duration / 2;
  
        printf "%.${tp}f:%s:%.5f:%.5f\n", $T4, $key, $d, $t;

        #print Dumper( \%h ) . "\nt0=$t0, T4=$T4\ndelay=$d, offset=$t\nelapsed=$duration, delta=$delta\n\n";
        #print "$server delay=$d, offset=$t, delta=$delta, duration=$duration\n";
        #print sprintf( "%-30s %.5f\n", $server, $t );
    }

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;
}



### Subroutines

## configuration file

# open JSON configuration file
sub open_config {

    my ($conf) = @_;

    my $json_data;

    {
        local $/;

        # we will parse now the file
        if ( defined $ENV{'KRMX_PREFIX'} ) {
            if ( -e "$ENV{'KRMX_PREFIX'}/etc/$conf" ) {
                open my $fh, "<", "$ENV{'KRMX_PREFIX'}/etc/$conf";
                $json_data = <$fh>;
                close $fh;
            }
            else {
                print "error: open_conf - $! $ENV{'KRMX_PREFIX'}/etc/$conf \n";
                usage();
            }
        }
        else {
            if ( -e "/opt/kronometrix/etc/$conf" ) {
                open my $fh, "<", "/opt/kronometrix/etc/$conf";
                $json_data = <$fh>;
                close $fh;
            }
            else {
                print "error: open_conf - $! /opt/kronometrix/etc/$conf \n";
                usage();
            }
        }
    }

    my $perl_data = JSON->new->utf8->decode($json_data);

    return $perl_data;
}


sub reload_config {

    write_log("info: main - signal HUP received, reload armed...");

    $cdata = open_config($cfile);

    ## hostid
    # get_hostid($cdata);

    ## appliance destination
    # %work = get_workload($cdata);

    return;
}


# get NTP Server defintion
sub get_server {

    my ($data) = @_;
    tie my %ntps, "Tie::IxHash";

    my @temp;
    eval { @temp = @{ $data->{'server'} }; };
    if ( $@ ) { die "Error: syntax error ntprec.conf, check server";  }
    
    foreach my $f (@temp) {

        my $host    = $f->{'hostname'};
        my $port    = $f->{'port'};
        my $desc    = $f->{'description'};

        # print "$host => $port:$desc \n";
        my $keyapp = $host;
        my $hvalue = $port . ":" . $desc;

        $ntps{$keyapp} = $hvalue;
    }

    return %ntps;
}


## auxiliares

# write log message
sub write_log {

    my ($logbuf) = @_;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

    my $dt = sprintf "%4d-%02d-%02d %02d:%02d:%02d",
      $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

    print STDERR "\n$dt $logbuf";

    return;
}


# usage - print usage and exit.
sub usage {
    print STDERR <<END;
USAGE: direc [-hvV] | [interval]
OPTIONS:
  -h        : help information
  -v        : verbose information
  -V        : release version
  interval  : maximum number of seconds between samples

 FIELDS:
  #01 timestamp : seconds since Epoch, time
  #02 capacity in KBytes
  #03 number of files, number
  #04 creation date, seconds
  #05 modified date, seconds
 
 NOTES:
  The recorder uses dirrec.json configuration file
END
    exit 0;
}

# revision - print revision and exit
sub revision {
    print STDERR <<END;
direc: 1.1.0, 2016-05-01 1255
END
    exit 0;
}
