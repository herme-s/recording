#!/opt/kronometrix/perl/bin/perl
#
#  Copyright (c) 2016 Stefan Parvu (www.kronometrix.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use JSON;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use POSIX qw(pause);
use Tie::IxHash;
use Device::Modbus::RTU::Client;
use Data::Dumper;

###  Process command line args
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hvV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# verbose flag
my $verbose = defined $main::opt_v ? $main::opt_v : 0;

# process [interval [count]],
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

###  Variables
my $loop = 0;                # current loop number
$main::opt_h = 0;            # help option
$main::opt_V = 0;            # revision option
my $cfile = 'rs485rec.json'; # configuration file
my $cdata;                   # configuration data
my $tp = 0;                  # time precision
my $port;
my $baudrate;
my $timeout;
my $parity;
my $stopbits;

local $| = 1;

### MAIN BODY #

# Set a timer
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .2, .2 );

### 0.2sec sleep using a timer
pause;

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

# check interval input
if ( $interval =~ /\./ ) {
    $tp = 3;
}

# we need all info
# read configuration
$cdata = open_config($cfile);

# workloads
tie my %devices, "Tie::IxHash";
%devices = get_devices($cdata);

# get it as verbose
if($verbose) {
    print "Total devices: " . keys(%devices) . ".\n";
    for my $key (keys %devices) {
        my $value = $devices{$key};
        print "$key => $value\n";
    }
}

# main loop
while (1) {

    for my $key (keys %devices) {

        my $value = $devices{$key};

        my ($id, $m, $f, $a, $q) = split( /:/, $key );

        my ($v, $p, $b, $par, $s, $t) = split( /:/, $value );

        print "Processing $key => $value ...\n";
        modbus_rtu($id, $f, $a, $q, $par, $s);
    }

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;
}


### Subroutines
## configuration file

# open JSON configuration file
sub open_config {

    my ($conf) = @_;

    my $json_data;

    {
        local $/;

        # we will parse now the file
        if ( defined $ENV{'KRMX_PREFIX'} ) {
            if ( -e "$ENV{'KRMX_PREFIX'}/etc/$conf" ) {
                open my $fh, "<", "$ENV{'KRMX_PREFIX'}/etc/$conf";
                $json_data = <$fh>;
                close $fh;
            }
            else {
                print "error: open_conf - $! $ENV{'KRMX_PREFIX'}/etc/$conf \n";
                usage();
            }
        }
        else {
            if ( -e "/opt/kronometrix/etc/$conf" ) {
                open my $fh, "<", "/opt/kronometrix/etc/$conf";
                $json_data = <$fh>;
                close $fh;
            }
            else {
                print "error: open_conf - $! /opt/kronometrix/etc/$conf \n";
                usage();
            }
        }
    }

    my $perl_data = JSON->new->utf8->decode($json_data);

    return $perl_data;
}


# get  defintion
sub get_devices {

    my ($data) = @_;
    tie my %devs, "Tie::IxHash";

    my @temp = @{ $data->{'modbus-rtu'} };

    foreach my $f (@temp) {
        my ($sid, $tid, $dsid);

        $port      = $f->{'port'};
        $baudrate  = $f->{'baudrate'};
        $timeout   = $f->{'timeout'};
        $parity    = $f->{'parity'};
        $stopbits  = $f->{'stopbits'};

        my @reqs = @{ $f->{'iaq'} };

        foreach my $dev (@reqs) {
            my $vendor   = $dev -> {'vendor'};
            my $model    = $dev -> {'model'};
            my $func     = $dev -> {'modbus-function'};

            # my @registers = @{ $f->{'data'} };

            # foreach my $data (@registers) {
            my $keyapp = $model . ":" . $vendor; 
            my $hvalue = $func;
            #  my $keyapp = $model . ":" . $func . ":" . 
            #             $addr . ":" . $qnty;
            #
            #    my $hvalue = $vendor . ":" . $port . ":" . $baudrate . ":" . 
            #             $parity . ":" . $stopbits . ":" . $timeout;
            #
            #    $devs{$keyapp} = $hvalue;
            #}
            print "Device: $model:$vendor:$func\n";
        }
    }

    return %devs;
}


sub modbus_rtu {

    my ( $unit, $function, $address, $quantity, $par, $sbits ) = @_;
    my $req;

    print "unit: $unit, function: $function, address: $address, quantity: $quantity, parity: $par, stopbits: $sbits\n";

    my $client = Device::Modbus::RTU::Client->new(
        port     => $port,
        baudrate => $baudrate,
        timeout  => $timeout,
        parity   => $par,
        stopbits => $sbits
    );

    if ( $function == 3 ) {
        $req = $client->read_holding_registers( unit     => $unit,
                                                address  => $address,
                                                quantity => $quantity );
    } elsif ( $function == 4 ) {
        $req = $client->read_input_registers( unit     => $unit,
                                              address  => $address,
                                              quantity => $quantity);
    } else { return; }

    $client->send_request($req);
    my $resp = $client->receive_response;

    for ( @{ $resp->{message}->{values} } ) {
        print "$_\n";
    }

    print $resp->{message}->{values}->[0];

    #print Dumper($resp);

    $client->disconnect;
}

#
sub putraw {

    my ( $timereq, $workload, $reqname,  $ttime, $ctime, $dtime, $ptime, $psize, $fpkt, $resp ) = @_;

    my $devid;

    if ($workload) {
        $devid = $workload . "_" . $reqname;
    } else {
        $devid = $reqname;
    }

    printf "%.${tp}f:%s:%.3f:%.3f:%.3f:%.3f:%.3f:%d:%d\n",
                $timereq, $devid,
                $ttime  , $ctime   , $dtime  , $ptime,
                $fpkt   , $psize   , $resp;
}


## auxiliares

# write log message
sub write_log {

    my ($logbuf) = @_;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

    my $dt = sprintf "%4d-%02d-%02d %02d:%02d:%02d",
      $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

    print STDERR "\n$dt $logbuf";

    return;
}


# usage - print usage and exit.
sub usage {
    print STDERR <<END;
USAGE: rs485rec [-hvV] | [interval]
OPTIONS:
  -h        : help information
  -v        : verbose information
  -V        : release version
  interval  : maximum number of seconds between samples

 MESSAGES:
 iaqrec - indoor air quality data message

 FIELDS:
  #01 timestamp : seconds since Epoch, time
  #02 devid     : the device id
  #03 ta        : air termperature, in C
  #04 rh        : relative humidity, in %
  #05 td        : dew point, in C
  #06 co2       : CO2 level, in ppm
  #07 voc       : volatile organic compound, in ppm

 NOTES
 rs485rec is a multi-message data recorder, capable to handle multiple 
 devices on RS485 wire, using different protocols, like: MODBUS RTU, 
 MODBUS TCP, MODBUS ASCII. Currently, rs485rec does support MODBUS RTU.
END
    exit 0;
}

# revision - print revision and exit
sub revision {
    print STDERR <<END;
rs485rec: 1.1.0, 2016-08-22 1243
END
    exit 0;
}
